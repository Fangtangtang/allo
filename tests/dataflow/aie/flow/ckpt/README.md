# Experimental Implementation
## CT forwarding

Shim -> Mem -> Comp -> adjacent Comp

```python
def test_transfer():
    Ty = int32
    M = 16

    @df.region()
    def top():
        pipe: Stream[Ty[M], 2]

        @df.kernel(mapping=[1])
        def producer(A: Ty[M]):
            # send data
            pipe.put(A)

        @df.kernel(mapping=[1])
        def consumer(B: Ty[M]):
            # receive data
            B[:] = allo.add(pipe.get(), 1)

    A = np.random.randint(0, 64, (M)).astype(np.int32)
    B = np.zeros((M), dtype=np.int32)

    mod = df.build(top, target="aie")
    mod(A, B)
    np.testing.assert_allclose(A + 1, B, atol=1e-5)
    print("Passed!")
```

- [objectfifo.mlir](./transfer/objectfifo.mlir): generated by allo
- [flow.mlir](./transfer/flow.mlir): partially lowered + manually clean up
- [opt_flow.mlir](./transfer/opt_flow.mlir): manually simplified, remove redundent `memref.copy`

## CT reuse
```python
def test_reuse():
    Ty = int32
    M = 16

    @df.region()
    def top():
        pipe: Stream[Ty[M], 2]

        @df.kernel(mapping=[1])
        def producer(A: Ty[M], B0: Ty[M]):
            B0[:] = allo.add(A, 1)
            # send data
            pipe.put(A)

        @df.kernel(mapping=[1])
        def consumer(B1: Ty[M]):
            # receive data
            B1[:] = allo.add(pipe.get(), 1)

    A = np.random.randint(0, 64, (M)).astype(np.int32)
    B0 = np.zeros((M), dtype=np.int32)
    B1 = np.zeros((M), dtype=np.int32)

    mod = df.build(top, target="aie")
    mod(A, B0, B1)
    np.testing.assert_allclose(A + 1, B0, atol=1e-5)
    np.testing.assert_allclose(A + 1, B1, atol=1e-5)
    print("Passed!")
```

- [objectfifo.mlir](./reuse/objectfifo.mlir): generated by allo
- [flow.mlir](./reuse/flow.mlir): partially lowered + manually clean up
- [opt_flow.mlir](./reuse/opt_flow.mlir): manually simplified, remove redundent `memref.copy`

**careful with `lock`!**
